% Created 2021-10-20 Wed 14:09
% Intended LaTeX compiler: xelatex
\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage{subcaption}
\usepackage{mathtools}
\usepackage{xfrac}
\usepackage[margin=1in]{geometry}
\usepackage{marginnote}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{epsf}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{pslatex}
\usepackage{hyperref}

%\usepackage{beton}
%\usepackage{euler}
%\usepackage[OT1]{fontenc}

\usepackage[T1]{fontenc}
\usepackage{newpxtext,eulerpx}

\usepackage{textgreek}
\renewcommand*{\textgreekfontmap}{%
{phv/*/*}{LGR/neohellenic/*/*}%
{*/b/n}{LGR/artemisia/b/n}%
{*/bx/n}{LGR/artemisia/bx/n}%
{*/*/n}{LGR/artemisia/m/n}%
{*/b/it}{LGR/artemisia/b/it}%
{*/bx/it}{LGR/artemisia/bx/it}%
{*/*/it}{LGR/artemisia/m/it}%
{*/b/sl}{LGR/artemisia/b/sl}%
{*/bx/sl}{LGR/artemisia/bx/sl}%
{*/*/sl}{LGR/artemisia/m/sl}%
{*/*/sc}{LGR/artemisia/m/sc}%
{*/*/sco}{LGR/artemisia/m/sco}%
}
\makeatletter
\newcommand*{\rom}[1]{\expandafter\@slowromancap\romannumeral #1@}
\makeatother
\DeclarePairedDelimiterX{\infdivx}[2]{(}{)}{%
#1\;\delimsize\|\;#2%
}
\newcommand{\infdiv}{D\infdivx}
\DeclarePairedDelimiter{\norm}{\left\lVert}{\right\rVert}
\DeclarePairedDelimiter{\ceil}{\left\lceil}{\right\rceil}
\DeclarePairedDelimiter{\floor}{\left\lfloor}{\right\rfloor}
\def\Z{\mathbb Z}
\def\R{\mathbb R}
\def\C{\mathbb C}
\def\N{\mathbb N}
\def\Q{\mathbb Q}
\def\noi{\noindent}
\onehalfspace
\usemintedstyle{bw}
\author{Sandy Urazayev, Jacob McNamee\thanks{University of Kansas (ctu@ku.edu)}}
\date{286; 12021 H.E.}
\title{Quash Report\\\medskip
\large EECS 678 Project \rom{1}}
\hypersetup{
 pdfauthor={Sandy Urazayev, Jacob McNamee},
 pdftitle={Quash Report},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.0.50 (Org mode 9.4.6)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\section{Quash}
\label{sec:org8e17f0a}
Quash is the best shell in the entirety of our existence. Let's walk through
how it's built!
\section{Forking and Executing}
\label{sec:org37b2698}
Quash is implemented in \href{https://golang.org}{Go}, which itself is a garbage-collected language that
runs threads to maintain the language runtime. When we want to fork from a Go
application, the forking will only spawn a copy of the thread that initiated
the forking. Therefore this new subprocess that just got forked lacks all the
supporting threads that Go applications \textbf{absolutely must have} for adequate
runtime performance. Therefore, Go does allow us to call \texttt{fork}, but we \textbf{have} to
run \texttt{exec} immediately, such that the call and execution stack is immediately
replaced by the newly loaded program.

This is achieved by \texttt{syscall.ForkExec} library call that only spawns a
subprocess with a loaded program and returns the new process's \texttt{pid}.
\begin{minted}[frame=lines,fontsize=\footnotesize,obeytabs,mathescape,numbersep=5pt,numbersep=2mm,xleftmargin=0.25in]{go}
pid, err := syscall.ForkExec(
        paths, args, &syscall.ProcAttr{
                Dir:   string,
                Env:   []string,
                Files: []uintptr,
                Sys:   &syscall.SysProcAttr{},
        })
\end{minted}
Notice that we have to pass in a couple of parameters, where \texttt{Dir} is the
current active directory where we are located, \texttt{Env} is a slice of strings, which
contains our environmental variables, \texttt{Files} is a slice of unsigned file
descriptor pointer values, and \texttt{Sys} is a struct to pass additional options.
\section{\texttt{PATH}}
\label{sec:orgc4d50d9}
In order to run executables, we have to have a list of directors where we
would look for one. For this, we have our \texttt{PATH} environmental variable. Quash
solves this problem rather simply by going through all the directories in \texttt{PATH}
and searching for an exact executable name match in their globs. The
binary finding code is below
\begin{minted}[frame=lines,fontsize=\footnotesize,obeytabs,mathescape,numbersep=5pt,numbersep=2mm,xleftmargin=0.25in]{go}
// lookPath tries to find an absolute path to an executable
// name by searching directories on the PATH
// If the name is an absolute path or a shortened path (./)
// then this path is returned
func lookPath(name string) (string, error) {
        if filepath.IsAbs(name) { //if the user has absolute path then we good
                return name, nil
        }

        absPath := filepath.Join(currDir, name)
        _, err := os.Stat(absPath)
        if !os.IsNotExist(err) {
                return absPath, nil
        }
        path := getenv("PATH")
        if path == "" {
                err := errors.New("executable not found")
                return "", err
        }
        directories := strings.Split(path, ":")
        for _, directory := range directories {
                dirInfo, err := os.ReadDir(directory)
                if err != nil {
                        //quashError("%s : %s", errors.Unwrap(err), directory)
                        continue
                }
                for _, file := range dirInfo {
                        if file.Name() == name && !file.IsDir() {
                                return directory + "/" + name, nil
                        }
                }
        }
        err = errors.New("executable not found")
        return "", err

}
\end{minted}
Notice that the function would return the full path for a binary (example if
\texttt{PATH = /usr/bin} and executable is \texttt{echo}, \texttt{lookPath} would return
\texttt{/usr/bin/echo}). \texttt{getenv} and \texttt{setenv} are our user-defined functions that access
the global variable \texttt{myEnv}, which holds all of our active environmental variables.
\section{Pipes}
\label{sec:orgd8e09c2}
Quash allows the user to sequentially run multiple programs while passing the
output data from one program to the input data of the next program in the
sequence. This is accomplished with the use of pipes. When Quash receives a
command, it separates the command into the programs the command wants us to
run and creates pipes to connect the processes to be created.
\begin{minted}[frame=lines,fontsize=\footnotesize,obeytabs,mathescape,numbersep=5pt,numbersep=2mm,xleftmargin=0.25in]{go}
// split input into different commands to be executed
commands := strings.Split(input, "|")
for index, command := range commands {
        commands[index] = strings.TrimSpace(command)
        args := strings.Split(commands[index], " ")
        args[0] = strings.TrimSpace(args[0])
        if builtinFunc, ok := builtins[args[0]]; ok && len(commands) == 1 {
                builtinFunc(args)
                addToHistory(input)
                return
        } else if ok {
                quashError("built-in command inside pipe chain")
                return
        }
}

pipeRead, pipeWrite := createPipes(len(commands) - 1)

\end{minted}
While the processes are being created (see Forking and Executing), the
processes are assigned a custom file descriptor table created using the
\texttt{fileDescriptor()} function. If there are pipes present in the command, then
\texttt{fileDescriptor()} will use the created pipes as files in the descriptor table,
overwriting the default behavior that uses the operating systemâ€™s standard
input (\texttt{stdin}) and standard output (\texttt{stdout}).
\begin{minted}[frame=lines,fontsize=\footnotesize,obeytabs,mathescape,numbersep=5pt,numbersep=2mm,xleftmargin=0.25in]{go}
// fileDescriptor returns a custom file descriptor for a call to ForkExec
// if there is only one command with no pipes, Stdin Stdout and Stderr are used
// pipes overwrite read, write, or both for processes inside of a pipe chain.
func fileDescriptor(
        index int,
        readPipe []*os.File,
        writePipe []*os.File,
        in *os.File,
        out *os.File,
        err *os.File,
) []uintptr {
        // One command, so no pipes
        if len(readPipe) == 0 {
                return []uintptr{
                        in.Fd(),
                        out.Fd(),
                        err.Fd(),
                }
        }
        // first in a chain
        if index == 0 {
                return []uintptr{
                        in.Fd(),
                        writePipe[0].Fd(),
                        err.Fd(),
                }
        }
        // last in a chain
        if index == len(readPipe) { ... }
        // middle of a chain
        return []uintptr{ ... }
}
\end{minted}
Finally, we must close the pipes within the quash process in order to properly
transmit EOF when a child process finishes execution. This is done using the
\texttt{closePipe()} function, which closes the pipe ends that we distributed to the
child process using the \texttt{fileDescriptor()} function.
\begin{minted}[frame=lines,fontsize=\footnotesize,obeytabs,mathescape,numbersep=5pt,numbersep=2mm,xleftmargin=0.25in]{go}
// closePipe closes used pipe ends based on where they are in a chain of piped
// commands if only one command exists, there are no pipes and this function
// does nothing.
func closePipe(index int, readPipe []*os.File, writePipe []*os.File) {
        // One command, so no pipes
        if len(readPipe) == 0 {
        } else if index == 0 {
                // first in a chain
                writePipe[0].Close()
        } else if index == len(readPipe) {
                // last in a chain
                readPipe[index-1].Close()
        } else {
                // middle of a chain
                readPipe[index-1].Close()
                writePipe[index].Close()
        }
}
\end{minted}
Note that in C you would have to also close excess pipes between the fork and
execute function calls in the child process, but in Go we only assigned the
child process the necessary pipes, so no additional pipes need to be closed. 
\section{Background Processes}
\label{sec:org72eea1a}
\section{Builtins}
\label{sec:org6c0805b}
\section{Arrow Keys}
\label{sec:orgc600fcc}
\end{document}