#+latex_class: sandy-article
#+latex_compiler: xelatex
#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+options: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+options: email:t f:t inline:t num:t p:nil pri:nil prop:nil stat:t tags:t
#+options: tasks:t tex:t timestamp:t title:t toc:t todo:t |:t num:t
#+language: en
#+html_head: <link rel="stylesheet" href="https://sandyuraz.com/styles/org.min.css">

#+title: Quash Report
#+subtitle: EECS 678 Project \rom{1}
#+author: Sandy Urazayev, Jacob McNamee
#+date: 286; 12021 H.E.
#+email: University of Kansas (ctu@ku.edu)
* Quash
  Quash is the best shell in the entirety of our existence. Let's walk through
  how it's built!
* Forking and Executing
  Quash is implemented in [[https://golang.org][Go]], which itself is a garbage-collected language that
  runs threads to maintain the language runtime. When we want to fork from a Go
  application, the forking will only spawn a copy of the thread that initiated
  the forking. Therefore this new subprocess that just got forked lacks all the
  supporting threads that Go applications *absolutely must have* for adequate
  runtime performance. Therefore, Go does allow us to call =fork=, but we *have* to
  run =exec= immediately, such that the call and execution stack is immediately
  replaced by the newly loaded program.

  This is achieved by =syscall.ForkExec= library call that only spawns a
  subprocess with a loaded program and returns the new process's =pid=.
  #+begin_src go
    pid, err := syscall.ForkExec(
            paths, args, &syscall.ProcAttr{
                    Dir:   string,
                    Env:   []string,
                    Files: []uintptr,
                    Sys:   &syscall.SysProcAttr{},
            })
  #+end_src
  Notice that we have to pass in a couple of parameters, where =Dir= is the
  current active directory where we are located, =Env= is a slice of strings, which
  contains our environmental variables, =Files= is a slice of unsigned file
  descriptor pointer values, and =Sys= is a struct to pass additional options.
* =PATH=
  In order to run executables, we have to have a list of directors where we
  would look for one. For this, we have our =PATH= environmental variable. Quash
  solves this problem rather simply by going through all the directories in =PATH=
  and searching for an exact executable name match in their globs. The
  binary finding code is below
  #+begin_src go
    // lookPath tries to find an absolute path to an executable
    // name by searching directories on the PATH
    // If the name is an absolute path or a shortened path (./)
    // then this path is returned
    func lookPath(name string) (string, error) {
            if filepath.IsAbs(name) { //if the user has absolute path then we good
                    return name, nil
            }
    
            absPath := filepath.Join(currDir, name)
            _, err := os.Stat(absPath)
            if !os.IsNotExist(err) {
                    return absPath, nil
            }
            path := getenv("PATH")
            if path == "" {
                    err := errors.New("executable not found")
                    return "", err
            }
            directories := strings.Split(path, ":")
            for _, directory := range directories {
                    dirInfo, err := os.ReadDir(directory)
                    if err != nil {
                            //quashError("%s : %s", errors.Unwrap(err), directory)
                            continue
                    }
                    for _, file := range dirInfo {
                            if file.Name() == name && !file.IsDir() {
                                    return directory + "/" + name, nil
                            }
                    }
            }
            err = errors.New("executable not found")
            return "", err
    
    }
  #+end_src
  Notice that the function would return the full path for a binary (example if
  =PATH = /usr/bin= and executable is =echo=, =lookPath= would return
  =/usr/bin/echo=). =getenv= and =setenv= are our user-defined functions that access
  the global variable =myEnv=, which holds all of our active environmental variables.
* Pipes
  Quash allows the user to sequentially run multiple programs while passing the
  output data from one program to the input data of the next program in the
  sequence. This is accomplished with the use of pipes. When Quash receives a
  command, it separates the command into the programs the command wants us to
  run and creates pipes to connect the processes to be created.
  #+begin_src go
    // split input into different commands to be executed
    commands := strings.Split(input, "|")
    for index, command := range commands {
            commands[index] = strings.TrimSpace(command)
            args := strings.Split(commands[index], " ")
            args[0] = strings.TrimSpace(args[0])
            if builtinFunc, ok := builtins[args[0]]; ok && len(commands) == 1 {
                    builtinFunc(args)
                    addToHistory(input)
                    return
            } else if ok {
                    quashError("built-in command inside pipe chain")
                    return
            }
    }
    
    pipeRead, pipeWrite := createPipes(len(commands) - 1)
    
  #+end_src
  While the processes are being created (see Forking and Executing), the
  processes are assigned a custom file descriptor table created using the
  =fileDescriptor()= function. If there are pipes present in the command, then
  =fileDescriptor()= will use the created pipes as files in the descriptor table,
  overwriting the default behavior that uses the operating systemâ€™s standard
  input (=stdin=) and standard output (=stdout=).
  #+begin_src go
    // fileDescriptor returns a custom file descriptor for a call to ForkExec
    // if there is only one command with no pipes, Stdin Stdout and Stderr are used
    // pipes overwrite read, write, or both for processes inside of a pipe chain.
    func fileDescriptor(
            index int,
            readPipe []*os.File,
            writePipe []*os.File,
            in *os.File,
            out *os.File,
            err *os.File,
    ) []uintptr {
            // One command, so no pipes
            if len(readPipe) == 0 {
                    return []uintptr{
                            in.Fd(),
                            out.Fd(),
                            err.Fd(),
                    }
            }
            // first in a chain
            if index == 0 {
                    return []uintptr{
                            in.Fd(),
                            writePipe[0].Fd(),
                            err.Fd(),
                    }
            }
            // last in a chain
            if index == len(readPipe) { ... }
            // middle of a chain
            return []uintptr{ ... }
    }
  #+end_src
  Finally, we must close the pipes within the quash process in order to properly
  transmit EOF when a child process finishes execution. This is done using the
  =closePipe()= function, which closes the pipe ends that we distributed to the
  child process using the =fileDescriptor()= function.
  #+begin_src go
    // closePipe closes used pipe ends based on where they are in a chain of piped
    // commands if only one command exists, there are no pipes and this function
    // does nothing.
    func closePipe(index int, readPipe []*os.File, writePipe []*os.File) {
            // One command, so no pipes
            if len(readPipe) == 0 {
            } else if index == 0 {
                    // first in a chain
                    writePipe[0].Close()
            } else if index == len(readPipe) {
                    // last in a chain
                    readPipe[index-1].Close()
            } else {
                    // middle of a chain
                    readPipe[index-1].Close()
                    writePipe[index].Close()
            }
    }
  #+end_src
  Note that in C you would have to also close excess pipes between the fork and
  execute function calls in the child process, but in Go we only assigned the
  child process the necessary pipes, so no additional pipes need to be closed. 
* Background Processes
* Builtins
* Arrow Keys
